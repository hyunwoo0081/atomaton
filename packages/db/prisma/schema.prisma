// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
  shadowDatabaseUrl = env("SHADOW_DATABASE_URL")
}

model User {
  id           String    @id @default(cuid())
  email        String    @unique
  password     String
  is_developer Boolean   @default(false)
  created_at   DateTime  @default(now())
  updated_at   DateTime  @updatedAt
  workflows    Workflow[]
  accounts     Account[]
}

model Account {
  id          String   @id @default(cuid())
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId      String
  type        String // e.g., "NAVER_IMAP"
  credentials Json // Encrypted credentials
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt
}

model Workflow {
  id         String    @id @default(cuid())
  name       String
  is_active  Boolean   @default(true)
  user       User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  userId     String
  trigger    Trigger?
  actions    Action[]
  logs       Log[]
  ui_config  Json?     // React Flow nodes & edges
  settings   Json?     // Global settings (failure alert, etc.)
  created_at DateTime  @default(now())
  updated_at DateTime  @updatedAt
}

model Trigger {
  id          String     @id @default(cuid())
  workflow    Workflow   @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workflowId  String     @unique
  type        String // "IMAP_POLLING" or "WEBHOOK"
  config      Json
  rules       Rule[]
  created_at  DateTime   @default(now())
  updated_at  DateTime   @updatedAt
}

model Rule {
  id         String   @id @default(cuid())
  trigger    Trigger  @relation(fields: [triggerId], references: [id], onDelete: Cascade)
  triggerId  String
  // Since we only support AND, we can have multiple rules per trigger
  field      String // e.g., "subject", "from"
  operator   String // "contains", "equals"
  value      String
  created_at DateTime @default(now())
  updated_at DateTime @updatedAt
}

model Action {
  id          String   @id @default(cuid())
  workflow    Workflow @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workflowId  String
  type        String // "DISCORD_WEBHOOK", "NOTION_PAGE", "CONDITION"
  config      Json
  order       Int // For sequential execution
  created_at  DateTime @default(now())
  updated_at  DateTime @updatedAt

  @@index([workflowId, order])
}

enum LogStatus {
  SUCCESS
  FAILURE
  SKIPPED
  ENQUEUED
}

model Log {
  id           String    @id @default(cuid())
  workflow     Workflow  @relation(fields: [workflowId], references: [id], onDelete: Cascade)
  workflowId   String
  triggerId    String?
  actionId     String?
  status       LogStatus // "SUCCESS", "FAILURE", "SKIPPED", "ENQUEUED"
  message      String    @db.Text
  context      Json?
  source       String?
  executionId  String?
  created_at   DateTime  @default(now())

  @@index([workflowId, created_at])
}
